# CSC-305 — Compiler Design
---
## ASSIGNMENT - 2
## Requirements & Dependencies

To build and run the code in this repository you will need the following tools installed on your development machine (instructions assume a Linux environment):

* `flex` — fast lexical analyzer generator
* `bison` — GNU parser generator (yacc-compatible)
* `g++` — GNU C++ compiler
* `libfl-dev` (or equivalent) — development library for linking `flex` generated code
* `make` — build automation utility

Example installation on Ubuntu/WSL:
sudo apt update
sudo apt install build-essential flex bison libfl-dev make

---

## Repo layout

.
├── makefile        # build rules
├── README.md
├── run.sh
├── src/
│   ├── lexer.l         # flex lexer source
│   ├── parser.y        # bison parser grammar
│   ├── lex.yy.c        # generated by flex (target of make)
│   ├── parser.tab.c    # generated by bison (target of make)
│   ├── parser.tab.h    # generated header by bison
│   ├── parser.output   # bison verbose output (conflicts/states)
│   ├── parser          # generated executable (target of make)
├── test/
│   ├── test1.txt
│   ├── test2.txt
│   └── ...             # input test files
└── output/
    ├── output1.txt 
    └── ...             # generated output (symbol & constant tables)

---

## Features

* A working **lexical analyzer** (implemented in `lexer.l`) that recognizes C/C++-style tokens: keywords, identifiers, literals, operators and punctuation.
* A complete **parser** (implemented in `parser.y`) that processes tokenized input according to C/C++ grammar rules.
* **Symbol Table Generation**: Tracks all identifiers with their data types, scope (IDENTIFIER, FUNCTION, PARAM, MEMBER), and line numbers.
* **Constant Table Generation**: Records all literal values (integers, doubles, strings, characters) with their types and source locations.
* **Grammar Support**: Handles variable declarations, function definitions, class/struct definitions, expressions, control structures, and more.
* **Error Reporting**: Provides detailed syntax error messages with line numbers and context.
* Simple `Makefile` to generate lexer/parser code and build the executable.

---

### Phase 1 — Lexical Analysis

**Location:** `lexer.l`

**What it does:**

* Tokenizes input source files into tokens such as `INT`, `DOUBLE`, `CHAR`, `IDENTIFIER`, `DECIMAL_LITERAL`, operators (`+`, `-`, `*`, `/`, `==`, `<=`, `&&`, `||`), punctuation (`;`, `,`, `{`, `}`), and various literals.
* Supports C++ keywords (`class`, `public`, `private`, `new`, `delete`), C I/O (`cin`, `cout`), and preprocessor directives.
* Handles invalid identifiers and provides appropriate error tokens.

### Phase 2 — Syntax Analysis & Parsing

**Location:** `parser.y`

**What it does:**

* Parses tokenized input according to comprehensive C/C++ grammar rules.
* Builds **Symbol Table** containing:
  - Variable declarations with data types
  - Function definitions with return types  
  - Class/struct definitions
  - Function parameters
  - Member variables
* Builds **Constant Table** recording all literal values found in source.
* Supports complex language constructs: pointers, arrays, nested expressions, control flow, OOP features.

---

## Running the project

### Build

From the project root:
# generate lex.yy.c, parser.tab.c and build the executable
make

Makefile targets:

* `parser` — runs `bison -d -v` and `flex`, then compiles with `g++ -lfl` to create `parser` executable.
* `clean` — removes generated files (`lex.yy.c`, `parser.tab.c`, `parser.tab.h`, `parser.output`, `parser`).

make clean
# removes all generated files


### Run

usage: ./parser < input_file > output_file
./parser < test/test1.txt > output/output1.txt

### Batch runs

A convenience script `run.sh` runs the lexer on multiple `test/` files and writes output to `output/`:

```bash
chmod +x run.sh
./run.sh
# run.sh runs the lexer on multiple test files and writes them to `output/`
```

### Output format

The parser generates two formatted ASCII tables to stdout:

#### 1. Symbol Table
SYMBOL TABLE
---------------------------------------------------------------
NAME                DATATYPE            TYPE                LINE      
---------------------------------------------------------------
a                   INT                 IDENTIFIER          4         
b                   INT                 IDENTIFIER          4   

#### 2. Constant Table
CONSTANT TABLE
---------------------------------------------------------------
VALUE                    TYPE                LINE      
---------------------------------------------------------------
5                        DECIMAL_LITERAL     4         
7                        DECIMAL_LITERAL     4         
"Greater than"               STRING_LITERAL      7


### Return codes

* `0` on successful parsing with table generation
* Non-zero on syntax errors or file I/O issues

---

### Contributors 
* Kartik Sarda - 23114047
* Nitin Agiwal - 23114074
* Adesh Kaduba Palkar - 23114004
* Utkarsh Kumar - 23114101



