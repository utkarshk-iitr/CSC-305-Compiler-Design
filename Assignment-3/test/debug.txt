Debug: struct_or_class -> CLASS
Debug: named struct/class: A
Debug: struct_or_class_member_list -> <empty>
Debug: lastClassType: A
Debug: access_specifier_label -> PUBLIC :
Debug: lastClassType: A
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: A
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: init_declarator -> IDENTIFIER 
Debug: 12d
Debug: global
Debug: 13
Debug: 
Debug: Declared variable is: d of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: external -> init_declarator_list ;
Debug: external_declaration -> type_specifier external
Debug: struct_or_class_member -> member_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: access_specifier_label -> PUBLIC :
Debug: lastClassType: A
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: A
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> CHAR
Debug: external_declaration -> type_specifier
Debug: type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: 
Debug: lastDeclType in external: char
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: Parameter: d of type int
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: init_declarator -> IDENTIFIER 
Debug: 
Debug: Declared variable is: c of type: char and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: primary_expression -> IDENTIFIER
Debug: c
Debug: 
Debug: Looking up symbol: c
Debug: 
Debug: 
Debug: Found symbol: c
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: 3
Debug: fn_int
Debug: Return type: char, Expected type: char
Debug: Method 'fn_int' has return statement returning 'c'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: external_declaration -> type_specifier external
Debug: struct_or_class_member -> member_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> CHAR
Debug: pointer_list -> *
Debug: pointer_list -> pointer_list *
Debug: external_declaration -> type_specifier pointer_list
Debug: 
Debug: lastDeclType in external_declaration: char**
Debug: 
Debug: type_specifier -> INT
Debug: pointer_list -> *
Debug: pointer_opt -> pointer_list
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: type_specifier -> INT
Debug: pointer_list -> *
Debug: pointer_opt -> pointer_list
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_list , parameter_declaration
Debug: type_specifier -> CHAR
Debug: pointer_list -> *
Debug: pointer_list -> pointer_list *
Debug: pointer_opt -> pointer_list
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_list , parameter_declaration
Debug: 
Debug: lastDeclType in external: char**
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: Parameter: a of type int*
Debug: Parameter: b of type int*
Debug: Parameter: c of type char**
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: init_declarator -> IDENTIFIER 
Debug: 
Debug: Declared variable is: o of type: char and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: pointer_list -> *
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: o
Debug: 
Debug: Looking up symbol: o
Debug: 
Debug: 
Debug: Found symbol: o
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> pointer_list IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared pointer: p1 of type: char* and kind: pointer
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: p1
Debug: 
Debug: Looking up symbol: p1
Debug: 
Debug: 
Debug: Found symbol: p1
Debug: Type: char*
Debug: Kind: pointer
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: 3
Debug: fn_int*_int*_char**
Debug: Return type: char**, Expected type: char**
Debug: Method 'fn_int*_int*_char**' has return statement returning 'fn_int*_int*_char**.t2'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: external_declaration -> type_specifier pointer_list external
Debug: struct_or_class_member -> member_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: access_specifier_label -> PROTECTED :
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: A
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: init_declarator -> IDENTIFIER 
Debug: 12p
Debug: global
Debug: 13
Debug: 
Debug: Declared variable is: p of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: external -> init_declarator_list ;
Debug: external_declaration -> type_specifier external
Debug: struct_or_class_member -> member_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: struct_or_class_specifier -> struct_or_class IDENTIFIER { struct_or_class_member_list }
Debug: external_declaration -> struct_or_class_specifier ;
Debug: translation_unit -> external_declaration
Debug: type_specifier -> CHAR
Debug: external_declaration -> type_specifier
Debug: type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: 
Debug: lastDeclType in external: char
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: 
Debug: Function 'fn_int' with return type 'char' declared.
Debug: Parameter: p of type int
Debug: 
Debug: constant -> CHARACTER_LITERAL
Debug: 
Debug: Character constant value: a
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: char, Expected type: char
Debug: 
Debug: lastDeclType: int
Debug: currentFunction: fn_int
Debug: 
Debug: Function 'fn_int' has return statement returning ''a''.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
Debug: type_specifier -> INT
Debug: pointer_list -> *
Debug: external_declaration -> type_specifier pointer_list
Debug: 
Debug: lastDeclType in external_declaration: int*
Debug: 
Debug: type_specifier -> INT
Debug: pointer_list -> *
Debug: pointer_opt -> pointer_list
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: 
Debug: lastDeclType in external: int*
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: 
Debug: Function 'fn_int*' with return type 'int*' declared.
Debug: Parameter: a of type int*
Debug: 
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: int*
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: int*, Expected type: int*
Debug: 
Debug: lastDeclType: int
Debug: currentFunction: fn_int*
Debug: 
Debug: Function 'fn_int*' has return statement returning 'a'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: external_declaration -> type_specifier pointer_list external
Debug: translation_unit -> translation_unit external_declaration
Debug: type_specifier -> CHAR
Debug: external_declaration -> type_specifier
Debug: 
Debug: lastFnType in external: char
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: Function 'main' with return type 'char' declared.
Debug: type_specifier -> TYPE_NAME
Debug: User defined type found: A
Debug: declaration_specifiers -> type_specifier
Debug: init_declarator -> IDENTIFIER 
Debug: 
Debug: Declared variable is: a of type: A and kind: 
Debug: 
Debug: 
Debug: Variable 'a.p' with type 'int' declared.
Debug: 1212
Debug: a.fn
Debug: zz
Debug: a.fn_int*_int*_char**
Debug: Function 'a.fn_int*_int*_char**' with return type 'char**' declared.
Debug: 1212
Debug: a.fn
Debug: zz
Debug: a.fn_int
Debug: Function 'a.fn_int' with return type 'char' declared.
Debug: Variable 'a.d' with type 'int' declared.
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 
Debug: a.fn
Debug: 
Debug: function
Debug: 1
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 7
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: a.fn
Debug: 
Debug: argCount is:1
Debug: type is int
Debug: name is: a.fn_int
Debug: YES
Debug: 
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared variable: c of type: char and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: constant_expression -> conditional_expression
Debug: square_opt -> [ constant_expression ]
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 1
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> assignment_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 2
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> initializer_list , assignment_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> initializer_list , assignment_expression
Debug: initializer -> { initializer_list }
Debug: init_declarator -> IDENTIFIER square_list = initializer 
Debug: 
Debug: Declared array: b of type: int* and kind: array
Debug: Dimension 1: 3
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: primary_expression -> IDENTIFIER
Debug: fn
Debug: 
Debug: Looking up symbol: fn
Debug: 
Debug: 
Debug: Found symbol: fn
Debug: Type: function
Debug: Kind: function
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: fn
Debug: 
Debug: argCount is:1
Debug: type is int
Debug: name is: fn_int
Debug: YES
Debug: 
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared variable: d of type: char and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared variable: p of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: init_declarator -> IDENTIFIER 
Debug: 
Debug: Declared variable is: o of type: char and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: pointer_list -> *
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: o
Debug: 
Debug: Looking up symbol: o
Debug: 
Debug: 
Debug: Found symbol: o
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> pointer_list IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared pointer: p1 of type: char* and kind: pointer
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: pointer_list -> *
Debug: pointer_list -> pointer_list *
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: p1
Debug: 
Debug: Looking up symbol: p1
Debug: 
Debug: 
Debug: Found symbol: p1
Debug: Type: char*
Debug: Kind: pointer
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> pointer_list IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared pointer: p2 of type: char** and kind: pointer
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: pointer_list -> *
Debug: pointer_list -> pointer_list *
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 
Debug: a.fn
Debug: 
Debug: function
Debug: 1
Debug: primary_expression -> IDENTIFIER
Debug: fn
Debug: 
Debug: Looking up symbol: fn
Debug: 
Debug: 
Debug: Found symbol: fn
Debug: Type: function
Debug: Kind: function
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int*
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: fn
Debug: 
Debug: argCount is:1
Debug: type is int*
Debug: name is: fn_int*
Debug: YES
Debug: 
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int*
Debug: 
Debug: primary_expression -> IDENTIFIER
Debug: fn
Debug: 
Debug: Looking up symbol: fn
Debug: 
Debug: 
Debug: Found symbol: fn
Debug: Type: function
Debug: Kind: function
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int*
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: fn
Debug: 
Debug: argCount is:1
Debug: type is int*
Debug: name is: fn_int*
Debug: YES
Debug: 
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> argument_expression_list , assignment_expression
Debug: 
Debug: argcount is 2, type is int*
Debug: 
Debug: primary_expression -> IDENTIFIER
Debug: p2
Debug: 
Debug: Looking up symbol: p2
Debug: 
Debug: 
Debug: Found symbol: p2
Debug: Type: char**
Debug: Kind: pointer
Debug: Dimensions: 0
Debug: 
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> argument_expression_list , assignment_expression
Debug: 
Debug: argcount is 3, type is char**
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: a.fn
Debug: 
Debug: argCount is:3
Debug: type is int*
Debug: type is int*
Debug: type is char**
Debug: name is: a.fn_int*_int*_char**
Debug: YES
Debug: 
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> pointer_list IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared pointer: q of type: char** and kind: pointer
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
