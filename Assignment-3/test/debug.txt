Debug: struct_or_class -> CLASS
Debug: named struct/class: A
Debug: struct_or_class_member_list -> <empty>
Debug: lastClassType: A
Debug: access_specifier_label -> PUBLIC :
Debug: lastClassType: A
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: A
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: 
Debug: lastDeclType in external: int
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: Parameter: x of type int
Debug: Parameter declared: x of type int
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333x
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: x of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 7
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333c
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: c of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: x
Debug: 
Debug: Looking up symbol: x
Debug: 
Debug: 
Debug: Found symbol: x
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: A.fn_int.x A.fn_int.x
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 7
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: A.fn_int.x
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: x
Debug: 
Debug: Looking up symbol: x
Debug: 
Debug: 
Debug: Found symbol: x
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: A.fn_int.x A.fn_int.x
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: 3
Debug: fn_int
Debug: Return type: int, Expected type: int
Debug: Method 'fn_int' has return statement returning 'x'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: 
Debug: fname: A.fn_int
Debug: lastFnType in external: int
Debug: 
Debug: external_declaration -> type_specifier external
Debug: struct_or_class_member -> external_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: declaration_specifiers -> const type_specifier
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 9
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: constint
Debug: 333e
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: e of type: int and kind: const
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration_specifiers -> const type_specifier init_declarator_list ;
Debug: external_declaration -> declare
Debug: struct_or_class_member -> external_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: type_specifier -> CHAR
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: type_specifier -> CHAR
Debug: pointer_list -> *
Debug: pointer_opt -> pointer_list
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_list , parameter_declaration
Debug: 
Debug: lastDeclType in external: int
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: Parameter: c of type char
Debug: Parameter: d of type char*
Debug: Parameter declared: c of type char
Debug: Parameter declared: d of type char*
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: cast_type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: primary_expression -> IDENTIFIER
Debug: c
Debug: 
Debug: Looking up symbol: c
Debug: 
Debug: 
Debug: Found symbol: c
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: A.fn_char_char*$c A.fn_char_char*$c
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: cast_expression -> ( cast_type ) cast_expression
Debug: ww
Debug: Casting from char to int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333f
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: f of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: pointer_list -> *
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: f
Debug: 
Debug: Looking up symbol: f
Debug: 
Debug: 
Debug: Found symbol: f
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: A.fn_char_char*.f A.fn_char_char*.f
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> pointer_list IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared pointer: e of type: int* and kind: pointer
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: cast_type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: primary_expression -> IDENTIFIER
Debug: c
Debug: 
Debug: Looking up symbol: c
Debug: 
Debug: 
Debug: Found symbol: c
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: A.fn_char_char*$c A.fn_char_char*$c
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: cast_expression -> ( cast_type ) cast_expression
Debug: ww
Debug: Casting from char to int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: 3
Debug: fn_char_char*
Debug: Return type: int, Expected type: int
Debug: Method 'fn_char_char*' has return statement returning 'fn_char_char*.t3'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: 
Debug: fname: A.fn_char_char*
Debug: lastFnType in external: int
Debug: 
Debug: external_declaration -> type_specifier external
Debug: struct_or_class_member -> external_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: 
Debug: lastFnType in external: int
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: 1
Debug: Method 'fn' with return type 'int' declared.
Debug: 2
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 7
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: 3
Debug: fn
Debug: Return type: int, Expected type: int
Debug: Method 'fn' has return statement returning '7'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declaration -> type_specifier external
Debug: struct_or_class_member -> external_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: declaration_specifiers -> static type_specifier
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: staticint
Debug: 333d
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: d of type: int and kind: static
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration_specifiers -> static type_specifier init_declarator_list ;
Debug: external_declaration -> declare
Debug: struct_or_class_member -> external_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 9
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333a
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: a of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: external -> init_declarator_list ;
Debug: external_declaration -> type_specifier external
Debug: struct_or_class_member -> external_declaration
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: struct_or_class_specifier -> struct_or_class IDENTIFIER { struct_or_class_member_list }
Debug: external_declaration -> struct_or_class_specifier ;
Debug: translation_unit -> external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333c
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: c of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: external -> init_declarator_list ;
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 9
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333d
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: d of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 10
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333e
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: e of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator_list , init_declarator
Debug: external -> init_declarator_list ;
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: 
Debug: lastDeclType in external: int
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: 
Debug: Function 'fn_int' with return type 'int' declared.
Debug: Parameter: x of type int
Debug: 
Debug: Parameter declared: x of type int
Debug: primary_expression -> IDENTIFIER
Debug: x
Debug: 
Debug: Looking up symbol: x
Debug: 
Debug: 
Debug: Found symbol: x
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: .fn_int$x .fn_int$x
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: int, Expected type: int
Debug: 
Debug: lastDeclType: int
Debug: currentFunction: fn_int
Debug: 
Debug: Function 'fn_int' has return statement returning 'x'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: 
Debug: fname: fn_int
Debug: lastFnType in external: int
Debug: 
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: type_specifier -> CHAR
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: type_specifier -> CHAR
Debug: pointer_list -> *
Debug: pointer_opt -> pointer_list
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_list , parameter_declaration
Debug: 
Debug: lastDeclType in external: int
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: 
Debug: Function 'fn_char_char*' with return type 'int' declared.
Debug: Parameter: c of type char
Debug: Parameter: d of type char*
Debug: 
Debug: Parameter declared: c of type char
Debug: Parameter declared: d of type char*
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: cast_type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: primary_expression -> IDENTIFIER
Debug: c
Debug: 
Debug: Looking up symbol: c
Debug: 
Debug: 
Debug: Found symbol: c
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: .fn_char_char*$c .fn_char_char*$c
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: cast_expression -> ( cast_type ) cast_expression
Debug: ww
Debug: Casting from char to int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333f
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: f of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: pointer_list -> *
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: f
Debug: 
Debug: Looking up symbol: f
Debug: 
Debug: 
Debug: Found symbol: f
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: fn_char_char*.f fn_char_char*.f
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> pointer_list IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared pointer: e of type: int* and kind: pointer
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: cast_type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: primary_expression -> IDENTIFIER
Debug: c
Debug: 
Debug: Looking up symbol: c
Debug: 
Debug: 
Debug: Found symbol: c
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: .fn_char_char*$c .fn_char_char*$c
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: cast_expression -> ( cast_type ) cast_expression
Debug: ww
Debug: Casting from char to int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: int, Expected type: int
Debug: 
Debug: lastDeclType: int
Debug: currentFunction: fn_char_char*
Debug: 
Debug: Function 'fn_char_char*' has return statement returning 'fn_char_char*.t3'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: 
Debug: fname: fn_char_char*
Debug: lastFnType in external: int
Debug: 
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: 
Debug: lastFnType in external: int
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: Function 'fn' with return type 'int' declared.
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: int, Expected type: int
Debug: 
Debug: lastDeclType: int
Debug: currentFunction: fn
Debug: 
Debug: Function 'fn' has return statement returning '8'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: type_specifier -> INT
Debug: pointer_list -> *
Debug: pointer_opt -> pointer_list
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_declaration
Debug: type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: parameter_list -> parameter_list , parameter_declaration
Debug: 
Debug: lastDeclType in external: int
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: 
Debug: Function 'array_sum_int*_int' with return type 'int' declared.
Debug: Parameter: arr of type int*
Debug: Parameter: size of type int
Debug: 
Debug: Parameter declared: arr of type int*
Debug: Parameter declared: size of type int
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333sm
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: sm of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333i
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: i of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: for_init_statement -> declaration
Debug: primary_expression -> IDENTIFIER
Debug: i
Debug: 
Debug: Looking up symbol: i
Debug: 
Debug: 
Debug: Found symbol: i
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: array_sum_int*_int.i array_sum_int*_int.i
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: primary_expression -> IDENTIFIER
Debug: size
Debug: 
Debug: Looking up symbol: size
Debug: 
Debug: 
Debug: Found symbol: size
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: .array_sum_int*_int$size .array_sum_int*_int$size
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> relational_expression < shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: primary_expression -> IDENTIFIER
Debug: i
Debug: 
Debug: Looking up symbol: i
Debug: 
Debug: 
Debug: Found symbol: i
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: array_sum_int*_int.i array_sum_int*_int.i
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression ++
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: primary_expression -> IDENTIFIER
Debug: sm
Debug: 
Debug: Looking up symbol: sm
Debug: 
Debug: 
Debug: Found symbol: sm
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: array_sum_int*_int.sm array_sum_int*_int.sm
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> +=
Debug: primary_expression -> IDENTIFIER
Debug: arr
Debug: 
Debug: Looking up symbol: arr
Debug: 
Debug: 
Debug: Found symbol: arr
Debug: Type: int*
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: .array_sum_int*_int$arr .array_sum_int*_int$arr
Debug: postfix_expression -> primary_expression
Debug: primary_expression -> IDENTIFIER
Debug: i
Debug: 
Debug: Looking up symbol: i
Debug: 
Debug: 
Debug: Found symbol: i
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: array_sum_int*_int.i array_sum_int*_int.i
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: postfix_expression -> postfix_expression [ expression ]
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:+
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: statement -> compound_statement
Debug: iteration_statement -> FOR ( for_init_statement expression_statement expression ) statement
Debug: statement -> iteration_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: sm
Debug: 
Debug: Looking up symbol: sm
Debug: 
Debug: 
Debug: Found symbol: sm
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: array_sum_int*_int.sm array_sum_int*_int.sm
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: int, Expected type: int
Debug: 
Debug: lastDeclType: int
Debug: currentFunction: array_sum_int*_int
Debug: 
Debug: Function 'array_sum_int*_int' has return statement returning 'sm'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: 
Debug: fname: array_sum_int*_int
Debug: lastFnType in external: int
Debug: 
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: 
Debug: lastFnType in external: int
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: Function 'main' with return type 'int' declared.
Debug: type_specifier -> TYPE_NAME
Debug: User defined type found: A
Debug: declaration_specifiers -> type_specifier
Debug: A
Debug: pointer_list -> *
Debug: init_declarator -> pointer_list IDENTIFIER 
Debug: 
Debug: Declared pointer: pr of type: A* and kind: pointer
Debug: 
Debug: mmm
Debug: main.*pr.a
Debug: Variable '*pr.a' with type 'int' declared.
Debug: mmm
Debug: main.*pr.d
Debug: Variable '*pr.d' with type 'int' declared.
Debug: *pr.fn
Debug: zzw
Debug: *pr.fn
Debug: Function '*pr.fn' with return type 'int' declared.
Debug: *pr.fn
Debug: zzw
Debug: *pr.fn_char_char*
Debug: Function '*pr.fn_char_char*' with return type 'int' declared.
Debug: mmm
Debug: main.*pr.e
Debug: Variable '*pr.e' with type 'int' declared.
Debug: *pr.fn
Debug: zzw
Debug: *pr.fn_int
Debug: Function '*pr.fn_int' with return type 'int' declared.
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: A
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: constant_expression -> conditional_expression
Debug: square_opt -> [ constant_expression ]
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 1
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> assignment_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 2
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> initializer_list , assignment_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> initializer_list , assignment_expression
Debug: initializer -> { initializer_list }
Debug: init_declarator -> IDENTIFIER square_list = initializer 
Debug: 
Debug: Declared array: arr of type: int* and kind: array
Debug: Dimension 1: 3
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: primary_expression -> IDENTIFIER
Debug: array_sum
Debug: 
Debug: Looking up symbol: array_sum
Debug: 
Debug: 
Debug: Found symbol: array_sum
Debug: Type: function
Debug: Kind: function
Debug: Dimensions: 0
Debug: 
Debug:  
Debug: postfix_expression -> primary_expression
Debug: primary_expression -> IDENTIFIER
Debug: arr
Debug: 
Debug: Looking up symbol: arr
Debug: 
Debug: 
Debug: Found symbol: arr
Debug: Type: int*
Debug: Kind: array
Debug: Dimensions: 1
Debug:  - 3
Debug: 
Debug: main.arr main.arr
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int*
Debug: 
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> argument_expression_list , assignment_expression
Debug: 
Debug: argcount is 2, type is int
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: array_sum
Debug: 
Debug: argCount is:2
Debug: type is int*
Debug: type is int
Debug: name is: array_sum_int*_int
Debug: mnb
Debug: array_sum_int*_int
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333s
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: s of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: printf
Debug: 
Debug: Looking up symbol: printf
Debug: 
Debug: postfix_expression -> primary_expression
Debug: constant -> STRING_LITERAL
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is char*
Debug: 
Debug: primary_expression -> IDENTIFIER
Debug: s
Debug: 
Debug: Looking up symbol: s
Debug: 
Debug: 
Debug: Found symbol: s
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.s main.s
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> argument_expression_list , assignment_expression
Debug: 
Debug: argcount is 2, type is int
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: printf
Debug: 
Debug: argCount is:2
Debug: type is char*
Debug: type is int
Debug: name is: printf_char*_int
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> TYPE_NAME
Debug: User defined type found: A
Debug: declaration_specifiers -> type_specifier
Debug: A
Debug: init_declarator -> IDENTIFIER 
Debug: 333a
Debug: 
Debug: Declared variable is: a of type: A and kind: 
Debug: 
Debug: 
Debug: mmm
Debug: main.a.a
Debug: Variable 'a.a' with type 'int' declared.
Debug: mmm
Debug: main.a.d
Debug: Variable 'a.d' with type 'int' declared.
Debug: a.fn
Debug: zz
Debug: a.fn
Debug: Function 'a.fn' with return type 'int' declared.
Debug: a.fn
Debug: zz
Debug: a.fn_char_char*
Debug: Function 'a.fn_char_char*' with return type 'int' declared.
Debug: mmm
Debug: main.a.e
Debug: Variable 'a.e' with type 'int' declared.
Debug: a.fn
Debug: zz
Debug: a.fn_int
Debug: Function 'a.fn_int' with return type 'int' declared.
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: A
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.a.a
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: postfix_expression -> postfix_expression ++
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.fn
Debug: 
Debug: function
Debug: 1
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: a.fn
Debug: 
Debug: argCount is:1
Debug: type is int
Debug: name is: a.fn_int
Debug: mnb
Debug: A.fn_int
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333z
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: z of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: char
Debug: constant -> CHARACTER_LITERAL
Debug: 
Debug: Character constant value: a
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: char
Debug: 333chr
Debug: Type of assignment expression: char
Debug: Type of variable: char
Debug: 
Debug: Declared variable: chr of type: char and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: char
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: cast_type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: primary_expression -> IDENTIFIER
Debug: chr
Debug: 
Debug: Looking up symbol: chr
Debug: 
Debug: 
Debug: Found symbol: chr
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.chr main.chr
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: cast_expression -> ( cast_type ) cast_expression
Debug: ww
Debug: Casting from char to int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: unary_expression -> ++ unary_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: unary_operator -> *
Debug: primary_expression -> IDENTIFIER
Debug: pr
Debug: 
Debug: Looking up symbol: pr
Debug: 
Debug: 
Debug: Found symbol: pr
Debug: Type: A*
Debug: Kind: pointer
Debug: Dimensions: 0
Debug: 
Debug: main.pr main.pr
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: primary_expression -> ( expression )
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: *pr.fn
Debug: 
Debug: function
Debug: 1
Debug: postfix_expression -> postfix_expression ( )
Debug: 2123
Debug: *pr.fn
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: fn
Debug: 
Debug: Looking up symbol: fn
Debug: 
Debug: 
Debug: Found symbol: fn
Debug: Type: function
Debug: Kind: function
Debug: Dimensions: 0
Debug: 
Debug:  
Debug: postfix_expression -> primary_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: fn
Debug: 
Debug: argCount is:1
Debug: type is int
Debug: name is: fn_int
Debug: mnb
Debug: fn_int
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.fn
Debug: 
Debug: function
Debug: 1
Debug: postfix_expression -> postfix_expression ( )
Debug: 2123
Debug: a.fn
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: fn
Debug: 
Debug: Looking up symbol: fn
Debug: 
Debug: 
Debug: Found symbol: fn
Debug: Type: function
Debug: Kind: function
Debug: Dimensions: 0
Debug: 
Debug:  
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression ( )
Debug: 2123
Debug: fn
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: constant_expression -> conditional_expression
Debug: square_opt -> [ constant_expression ]
Debug: init_declarator -> IDENTIFIER square_list 
Debug: 
Debug: Array dimensions: 
Debug:  - 3
Debug: 
Debug: 
Debug: Declared array: ar1 of type: int* and kind: array
Debug: Dimension 1: 3
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: ar1
Debug: 
Debug: Looking up symbol: ar1
Debug: 
Debug: 
Debug: Found symbol: ar1
Debug: Type: int*
Debug: Kind: array
Debug: Dimensions: 1
Debug:  - 3
Debug: 
Debug: main.ar1 main.ar1
Debug: postfix_expression -> primary_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: postfix_expression -> postfix_expression [ expression ]
Debug: 
Debug: Array dimensions: 
Debug: 1
Debug: Dimension size: 3
Debug: 
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333p
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: p of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: pointer_list -> *
Debug: unary_operator -> &
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: unary_expression -> unary_operator cast_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> pointer_list IDENTIFIER = assignment_expression 
Debug: 
Debug: Declared pointer: ptr of type: int* and kind: pointer
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> multiplicative_expression * cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> additive_expression + multiplicative_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 6
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 2
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> multiplicative_expression / cast_expression
Debug: additive_expression -> additive_expression + multiplicative_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> additive_expression + multiplicative_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> additive_expression - multiplicative_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 4
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> multiplicative_expression * cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 4
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> additive_expression + multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: primary_expression -> ( expression )
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> additive_expression + multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: primary_expression -> ( expression )
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> additive_expression - multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333f
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: f of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> equality_expression == relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 7
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.a.a
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: statement -> compound_statement
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.a.a
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: statement -> compound_statement
Debug: selection_statement -> if ( expression ) statement else statement
Debug: statement -> selection_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: f
Debug: 
Debug: Looking up symbol: f
Debug: 
Debug: 
Debug: Found symbol: f
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.f main.f
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> +=
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:+
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: f
Debug: 
Debug: Looking up symbol: f
Debug: 
Debug: 
Debug: Found symbol: f
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.f main.f
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> >>=
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:>>
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: f
Debug: 
Debug: Looking up symbol: f
Debug: 
Debug: 
Debug: Found symbol: f
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.f main.f
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> <<=
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:<<
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: f
Debug: 
Debug: Looking up symbol: f
Debug: 
Debug: 
Debug: Found symbol: f
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.f main.f
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> *=
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 7
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> multiplicative_expression * cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: primary_expression -> ( expression )
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:*
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> additive_expression + multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333d
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: d of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: char
Debug: cast_type_specifier -> CHAR
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: cast_expression -> ( cast_type ) cast_expression
Debug: ww
Debug: Casting from int to char
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: char
Debug: 333c
Debug: Type of assignment expression: char
Debug: Type of variable: char
Debug: 
Debug: Declared variable: c of type: char and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: char
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: constant_expression -> conditional_expression
Debug: square_opt -> [ constant_expression ]
Debug: init_declarator -> IDENTIFIER square_list 
Debug: 
Debug: Array dimensions: 
Debug:  - 3
Debug: 
Debug: 
Debug: Declared array: ar1 of type: int* and kind: array
Debug: Dimension 1: 3
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: primary_expression -> IDENTIFIER
Debug: ar1
Debug: 
Debug: Looking up symbol: ar1
Debug: 
Debug: 
Debug: Found symbol: ar1
Debug: Type: int*
Debug: Kind: array
Debug: Dimensions: 1
Debug:  - 3
Debug: 
Debug: main..ar1 main..ar1
Debug: postfix_expression -> primary_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: postfix_expression -> postfix_expression [ expression ]
Debug: 
Debug: Array dimensions: 
Debug: 1
Debug: Dimension size: 3
Debug: 
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: constant_expression -> conditional_expression
Debug: square_opt -> [ constant_expression ]
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: constant_expression -> conditional_expression
Debug: square_list -> square_list [ constant_expression ]
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> assignment_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> initializer_list , assignment_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> initializer_list , assignment_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> initializer_list , assignment_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: initializer_list -> initializer_list , assignment_expression
Debug: initializer -> { initializer_list }
Debug: init_declarator -> IDENTIFIER square_list = initializer 
Debug: 
Debug: Declared array: ar2 of type: int** and kind: array
Debug: Dimension 1: 3
Debug: Dimension 2: 3
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333z
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: z of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 8
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333p
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: p of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: ar2
Debug: 
Debug: Looking up symbol: ar2
Debug: 
Debug: 
Debug: Found symbol: ar2
Debug: Type: int**
Debug: Kind: array
Debug: Dimensions: 2
Debug:  - 3
Debug:  - 3
Debug: 
Debug: main..ar2 main..ar2
Debug: postfix_expression -> primary_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 3
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: postfix_expression -> postfix_expression [ expression ]
Debug: 
Debug: Array dimensions: 
Debug: 2
Debug: Dimension size: 3
Debug: Dimension size: 3
Debug: 
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 1
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: postfix_expression -> postfix_expression [ expression ]
Debug: 
Debug: Array dimensions: 
Debug: 1
Debug: Dimension size: 3
Debug: 
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 2
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.t34
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main..z main..z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: ar2
Debug: 
Debug: Looking up symbol: ar2
Debug: 
Debug: 
Debug: Found symbol: ar2
Debug: Type: int**
Debug: Kind: array
Debug: Dimensions: 2
Debug:  - 3
Debug:  - 3
Debug: 
Debug: main..ar2 main..ar2
Debug: postfix_expression -> primary_expression
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 1
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: postfix_expression -> postfix_expression [ expression ]
Debug: 
Debug: Array dimensions: 
Debug: 2
Debug: Dimension size: 3
Debug: Dimension size: 3
Debug: 
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 2
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: postfix_expression -> postfix_expression [ expression ]
Debug: 
Debug: Array dimensions: 
Debug: 1
Debug: Dimension size: 3
Debug: 
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main..z main..z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 10
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main..z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main..z main..z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main..p main..p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 12
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: init_declarator -> IDENTIFIER = assignment_expression 
Debug: int
Debug: 333z
Debug: Type of assignment expression: int
Debug: Type of variable: int
Debug: 
Debug: Declared variable: z of type: int and kind: 
Debug: 
Debug: nmnmn
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main...z main...z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 12
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main...z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: statement -> compound_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> TYPE_NAME
Debug: User defined type found: A
Debug: declaration_specifiers -> type_specifier
Debug: A
Debug: init_declarator -> IDENTIFIER 
Debug: 333b
Debug: 
Debug: Declared variable is: b of type: A and kind: 
Debug: 
Debug: 
Debug: mmm
Debug: main..b.a
Debug: Variable 'b.a' with type 'int' declared.
Debug: mmm
Debug: main..b.d
Debug: Variable 'b.d' with type 'int' declared.
Debug: b.fn
Debug: zz
Debug: b.fn
Debug: Function 'b.fn' with return type 'int' declared.
Debug: b.fn
Debug: zz
Debug: b.fn_char_char*
Debug: Function 'b.fn_char_char*' with return type 'int' declared.
Debug: mmm
Debug: main..b.e
Debug: Variable 'b.e' with type 'int' declared.
Debug: b.fn
Debug: zz
Debug: b.fn_int
Debug: Function 'b.fn_int' with return type 'int' declared.
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: A
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: b
Debug: 
Debug: Looking up symbol: b
Debug: 
Debug: 
Debug: Found symbol: b
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main..b main..b
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: b.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.a main.a
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: a.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: statement -> compound_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> TYPE_NAME
Debug: User defined type found: A
Debug: declaration_specifiers -> type_specifier
Debug: A
Debug: init_declarator -> IDENTIFIER 
Debug: 333b
Debug: 
Debug: Declared variable is: b of type: A and kind: 
Debug: 
Debug: 
Debug: mmm
Debug: main.b.a
Debug: Variable 'b.a' with type 'int' declared.
Debug: mmm
Debug: main.b.d
Debug: Variable 'b.d' with type 'int' declared.
Debug: b.fn
Debug: zz
Debug: b.fn
Debug: Function 'b.fn' with return type 'int' declared.
Debug: b.fn
Debug: zz
Debug: b.fn_char_char*
Debug: Function 'b.fn_char_char*' with return type 'int' declared.
Debug: mmm
Debug: main.b.e
Debug: Variable 'b.e' with type 'int' declared.
Debug: b.fn
Debug: zz
Debug: b.fn_int
Debug: Function 'b.fn_int' with return type 'int' declared.
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: A
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: b
Debug: 
Debug: Looking up symbol: b
Debug: 
Debug: 
Debug: Found symbol: b
Debug: Type: A
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.b main.b
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentType is A
Debug: 2ss12121
Debug: b.a
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 11
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: main.z
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: z
Debug: 
Debug: Looking up symbol: z
Debug: 
Debug: 
Debug: Found symbol: z
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.z main.z
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: p
Debug: 
Debug: Looking up symbol: p
Debug: 
Debug: 
Debug: Found symbol: p
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: main.p main.p
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: int, Expected type: int
Debug: 
Debug: lastDeclType: A
Debug: currentFunction: main
Debug: 
Debug: Function 'main' has return statement returning '0'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
