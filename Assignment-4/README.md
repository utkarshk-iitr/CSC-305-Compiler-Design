# CSC-305 — Compiler Design

---

## ASSIGNMENT - 4

## Requirements & Dependencies

To build and run the code in this repository you will need the following tools installed on your development machine (instructions assume a Linux environment):

* `flex` — fast lexical analyzer generator
* `bison` — GNU parser generator (yacc-compatible)
* `g++` — GNU C++ compiler
* `libfl-dev` (or equivalent) — development library for linking `flex` generated code
* `make` — build automation utility
* `nasm` — Netwide Assembler (for assembling x86 assembly code)
* `ld` — GNU linker (usually comes with build-essential)

Example installation on Ubuntu/WSL:

```bash
sudo apt update
sudo apt install build-essential flex bison libfl-dev make nasm
```

---

## Repo layout

```
.
├── Makefile            # build rules for parser and code generator
├── README.md
├── run.sh              # batch run parser on test files
├── run_codegen.sh      # batch run code generator on TAC output
├── src/
│   ├── lexer.l         # flex lexer source
│   ├── parser.y        # bison parser grammar (generates TAC)
│   ├── lex.yy.c        # generated by flex
│   ├── parser.tab.c    # generated by bison
│   ├── parser.tab.h    # generated header by bison
│   ├── parser.output   # bison verbose output
│   ├── parser          # parser executable (generates TAC)
│   ├── codegen.cpp     # x86 code generator (TAC → x86 assembly)
│   ├── codegen         # code generator executable
├── test/
│   ├── test1.txt
│   ├── test2.txt
│   └── ...             # C/C++ source test files
├── output/
│   ├── output1.txt     # generated x86 assembly
│   ├── output2.txt
│   └── ...
```

---

## Features

* A working **lexical analyzer** (implemented in `lexer.l`) that recognizes C/C++-style tokens: keywords, identifiers, literals, operators and punctuation.
* A complete **parser** (implemented in `parser.y`) that processes tokenized input according to C/C++ grammar rules.
* **Symbol Table Generation**: Tracks all identifiers with their data types, scope (IDENTIFIER, FUNCTION), types and kind.
* **Grammar Support**: Handles variable declarations, function definitions, class/struct definitions, expressions, control structures, and more.
* **Three-Address Code (TAC) Generation**: Emits intermediate representation suitable for optimization and code generation.
* **x86 Assembly Code Generation**: Translates TAC to x86 assembly language (implemented in `codegen.cpp`).
* **Assembling & Linking**: Generated assembly can be assembled with NASM and linked to produce native executables.

---

## Compiler Pipeline

### Phase 1 — Lexical Analysis

**Location:** `lexer.l`

**What it does:**

* Tokenizes input source files into tokens such as `INT`, `FLOAT`, `CHAR`, `IDENTIFIER`, `DECIMAL_LITERAL`, operators (`+`, `-`, `*`, `/`, `==`, `<=`, `&&`, `||`), punctuation (`;`, `,`, `{`, `}`), and various literals.
* Supports C++ keywords (`class`, `public`, `private`, `new`, `delete`), C I/O (`cin`, `cout`), and preprocessor directives.
* Handles invalid identifiers and provides appropriate error tokens.

---

### Phase 2 — Syntax Analysis & Parsing

**Location:** `parser.y`

**What it does:**

* Parses tokenized input according to comprehensive C/C++ grammar rules.
* Builds **Symbol Table** containing:
  * Variable declarations with data types
  * Function definitions with return types
  * Class/struct definitions
  * Function parameters
  * Member variables

---

### Phase 3 — Intermediate Code Generation (TAC)

**Location:** `parser.y` (semantic actions), output sent to `codegen.cpp`

**What it does:**

This phase extends the parser to emit **Three-Address Code (TAC)** — a linearized, low-level representation of the program suitable for optimization and target-code generation.

**Key behaviours:**

* **Expression lowering:** Complex expressions are decomposed into sequences of TAC statements using temporary variables (`t1`, `t2`, ...).
* **Temporary & label generation:** Parser maintains counters for unique temporary names and labels (`L1`, `L2`, ...).
* **Control-flow constructs:** `if`, `if-else`, `while`, `for`, `break`, `continue`, and `return` generate conditional/unconditional jumps with labels; uses backpatching for forward references.
* **Function calls & parameters:** Arguments are evaluated and passed (`param x`), followed by call sequences (`call f, n`) and returns (`return t`).
* **Assignments & memory ops:** Simple assignments (`a = b`) and array/pointer operations are emitted as TAC assignments or address operations.

**TAC Output Format:**

```
main:
    param "%d %d"
    main.t1 = &main.a
    param main.t1
    main.t2 = &main.b
    param main.t2
    main.t3 = call scanf, 3
    main.t4 = main.a + main.b
    main.sum = main.t4
    param "Sum: %d\n"
    param main.sum
    main.t10 = call printf, 2
    return 0
```

---

### Phase 4 — x86 Assembly Code Generation

**Location:** `src/codegen.cpp`

**What it does:**

This phase translates Three-Address Code into **x86 assembly language**.

**Key features:**

* **Register allocation:** Maps variables and temporaries to x86 registers (EAX, EBX, ECX, EDX, etc.) or stack locations.
* **Instruction selection:** TAC operations are translated to appropriate x86 instructions:
  * Arithmetic: `add`, `sub`, `imul`, `idiv`
  * Comparisons: `cmp` followed by conditional jumps (`je`, `jne`, `jl`, `jg`, etc.)
  * Memory access: `mov` for loads/stores
  * Function calls: `push`/`pop` for parameter passing, `call`/`ret` for function invocation
* **Control flow:** Labels and jumps (`jmp`, `jcc`) implement if/else, loops, and switch statements.
* **Stack frame management:** Prologue/epilogue code manages function activation records (base pointer, stack pointer).
* **External function linkage:** Supports calling C standard library functions (`printf`, `scanf`, etc.).

**Generated Assembly Format:**

```asm
section .data
    str_1 db `%f\n`, 0

section .text
    global main
    extern printf
    extern scanf
    extern malloc
    extern free
    extern nullptr

main:
    push ebp
    mov ebp, esp
    sub esp, 8
    mov dword [ebp-4], 0x3F8CCCCD
    sub esp, 8
    movss xmm0, [ebp-4]
    cvtss2sd xmm0, xmm0
    movsd [esp], xmm0
    mov eax, str_1
    push eax
    call printf
    mov [ebp-8], eax
    add esp, 12
    xor eax, eax
    mov esp, ebp
    pop ebp
    ret

```

---

## Building & Running

### 1. Build the Codegen

```bash
make
```

This compiles `src/parser.y src/lexer.l src/codegen.cpp` to `src/codegen` executable.

### 3. Run Codegen on Single Test File

```bash
./src/parser < test/test1.txt > output/output1.txt
```

This generates x86 assembly in `output/output1.txt`.

### 5. Assemble and Link x86 Code

For 64-bit Linux:

```bash
nasm -f elf64 output/output1.txt -o output/output1.o
ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc output/output1.o -o output/output1
```

Or if your assembly uses C library without explicit linking:

```bash
nasm -f elf64 output/output1.txt -o output/output1.o
gcc output/output1.o -o output/output1
```

### 6. Execute Generated Binary

```bash
./output/output1
```

---

## Batch Processing

### Generate Assembly for All Tests

```bash
chmod +x run.sh
./run.sh
```

This runs the parser on all `test/*.txt` files and writes Assembly output to `output/`.

---

## Directory Structure Details

| Path | Description |
|------|-------------|
| `src/lexer.l` | Flex lexer specification |
| `src/parser.y` | Bison parser with TAC generation |
| `src/codegen.cpp` | TAC to x86 assembly translator |
| `test/` | Input C/C++ source files |
| `output/` | Generated Codegen files |

---

## Modifications & Design Choices

* **Case statement syntax:** In our compiler, case statements use curly braces `{}` instead of colons `:` to enclose their blocks.
* **TAC format:** Function-scoped temporaries use `function.tN` naming convention.
* **Assembly syntax:** Generated code uses Intel syntax (operands are `destination, source`).
* **Calling convention:** Follows System x86 NASM style.

---

## Return Codes

* `0` — Successful compilation and code generation
* Non-zero — Syntax errors, semantic errors, or I/O issues

---

## Contributors

* Adesh Kaduba Palkar - 23114004
* Kartik Sarda - 23114047
* Nitin Agiwal - 23114074
* Utkarsh Kumar - 23114101

---