# Code Generator - Three-Address Code to x86 Assembly

## Overview
This code generator converts three-address code (TAC) generated by the parser into actual x86 assembly language that can be assembled and linked using NASM and GCC.

## Features

### Supported Operations
1. **Arithmetic Operations**: `+`, `-`, `*`, `/`, `%`
2. **Bitwise Operations**: `&`, `|`, `^`, `<<`, `>>`
3. **Comparison Operations**: `==`, `!=`, `<`, `>`, `<=`, `>=`
4. **Unary Operations**: `-` (negation), `~` (bitwise NOT), `!` (logical NOT)
5. **Memory Operations**: 
   - Address-of: `&variable`
   - Dereference: `*pointer`
   - Array indexing
6. **Control Flow**:
   - Conditional jumps: `ifFalse`, `if-goto`
   - Unconditional jumps: `goto`
   - Labels
7. **Function Operations**:
   - Function calls with parameters
   - Return statements
   - Stack frame management

### x86 Assembly Features
- Uses standard x86 32-bit calling conventions
- Proper stack frame setup with `ebp` and `esp`
- Efficient register usage
- Handles memory-to-memory operations via intermediate registers
- Proper handling of signed arithmetic and comparisons

## Building

### Prerequisites
- GCC/G++ compiler
- Make utility
- NASM (for assembling generated code)

### Compilation
```bash
# Build just the code generator
make codegen

# Build both parser and code generator
make all

# Clean all build artifacts
make clean
```

## Usage

### Basic Usage
```bash
./src/codegen <input_tac_file> [output_asm_file]
```

### Example
```bash
# Generate x86 assembly from TAC
./src/codegen output/output1.txt output/x86/test1.asm

# Assemble and link the generated code
nasm -f elf32 output/x86/test1.asm -o output/x86/test1.o
gcc -m32 output/x86/test1.o -o output/x86/test1
./output/x86/test1
```

### Automated Script
Use the provided script to process all test files:
```bash
chmod +x run_codegen.sh
./run_codegen.sh
```

## Three-Address Code Format

The code generator expects TAC in the following format:

### Data Section
```
variable_name resd 1          ; Reserve doubleword
string_name db "text", 0      ; String literal
variable = constant           ; Global initialization
```

### Code Section
```
function_name:                ; Function label
    push ebp                  ; Stack setup
    mov ebp, esp
    sub esp, N                ; Allocate local space
    
    [ebp - offset] = value    ; Assignment
    [ebp - offset] = op1 + op2; Binary operation
    ifFalse condition goto L1 ; Conditional jump
    goto L2                   ; Unconditional jump
    
    result = call func, N     ; Function call
    return value              ; Return statement
```

## Generated x86 Assembly Structure

### Sections
```nasm
section .data
    ; Global variables and strings
    
section .text
    global main
    extern printf
    extern scanf
    
main:
    ; Function prologue
    push ebp
    mov ebp, esp
    sub esp, N
    
    ; Function body
    
    ; Function epilogue
    mov esp, ebp
    pop ebp
    ret
```

### Register Usage
- `eax`: Primary accumulator, function return values
- `ebx`: General purpose, temporary storage
- `ecx`: Counter register (for shifts)
- `edx`: Data register (division remainder)
- `ebp`: Base pointer (stack frame)
- `esp`: Stack pointer

## Conversion Examples

### Simple Assignment
**TAC**: `[ebp - 4] = 10`
**x86**: 
```nasm
mov DWORD [ebp-4], 10
```

### Arithmetic Operation
**TAC**: `[ebp - 8] = [ebp - 4] + 5`
**x86**:
```nasm
mov eax, [ebp-4]
add eax, 5
mov [ebp-8], eax
```

### Comparison
**TAC**: `[ebp - 12] = [ebp - 4] >= 6`
**x86**:
```nasm
mov eax, [ebp-4]
cmp eax, 6
setge al
movzx eax, al
mov [ebp-12], eax
```

### Conditional Jump
**TAC**: `ifFalse [ebp - 12] goto main.L3`
**x86**:
```nasm
mov eax, [ebp-12]
test eax, eax
jz main.L3
```

### Function Call
**TAC**:
```
param [esp], str_1
param [esp], [ebp - 4]
[ebp - 8] = call printf, 2
```
**x86**:
```nasm
push str_1
mov eax, [ebp-4]
push eax
call printf
mov [ebp-8], eax
```

## Limitations and Future Enhancements

### Current Limitations
1. Only 32-bit x86 assembly (can be extended to 64-bit)
2. Limited floating-point support
3. Basic optimization only

### Potential Enhancements
1. Register allocation optimization
2. Peephole optimization
3. Dead code elimination
4. Constant folding
5. Support for x86-64 architecture
6. Better handling of complex expressions
7. Inline assembly support

## Testing

The `test/` directory contains various test cases demonstrating:
- Basic I/O operations
- Conditional statements (if-else)
- Switch statements
- Loops (for, while, do-while, until)
- Functions
- Arrays and pointers
- Goto statements

Each test case generates:
1. TAC output in `output/` directory
2. x86 assembly in `output/x86/` directory

## Debugging

Enable debugging output by examining:
- `debug.txt`: Parser debug information
- Generated assembly: Check for proper instruction sequences
- Use GDB for runtime debugging of generated executables

## Integration with Parser

The code generator is designed to work with the parser from Assignment-4:
1. Parser reads source code and generates TAC
2. Code generator reads TAC and produces x86 assembly
3. Assembly can be compiled and executed

## References
- Intel x86 Architecture Manual
- NASM Documentation
- System V ABI (Application Binary Interface)
- GCC Calling Conventions

## Author
Assignment-4 Code Generator
CSC-305 Compiler Design
