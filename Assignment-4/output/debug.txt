Debug: struct_or_class -> CLASS
Debug: named struct/class: Demo
Debug: struct_or_class_member_list -> <empty>
Debug: lastClassType: Demo
Debug: access_specifier_label -> PUBLIC :
Debug: lastClassType: Demo
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: Demo
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: type_specifier -> INT
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333pubValue
Debug: utla
Debug: 12pubValue
Debug: 
Debug: 13
Debug: offset of pubValue is 0
Debug: 
Debug: Declared variable is: pubValue of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: external -> init_declarator_list ;
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: Demo
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: access_specifier_label -> PRIVATE :
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: Demo
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: type_specifier -> INT
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333privValue
Debug: utla
Debug: 12privValue
Debug: 
Debug: 13
Debug: offset of privValue is 4
Debug: 
Debug: Declared variable is: privValue of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: external -> init_declarator_list ;
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: Demo
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: access_specifier_label -> PROTECTED :
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: Demo
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: type_specifier -> INT
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333protValue
Debug: utla
Debug: 12protValue
Debug: 
Debug: 13
Debug: offset of protValue is 8
Debug: 
Debug: Declared variable is: protValue of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: external -> init_declarator_list ;
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: Demo
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: access_specifier_label -> PUBLIC :
Debug: lastClassType: Demo
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: Demo
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: type_specifier -> VOID
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: void
Debug: type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: Parameter: v of type which is: int
Debug: parameter_list -> parameter_declaration
Debug: 
Debug: lastDeclType in external: void
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: Parameter: v of type int
Debug: Parameter declare: v of type int
Debug: int
Debug: q: int
Debug: stars: 
Debug: 12qwr
Debug: 0
Debug: primary_expression -> IDENTIFIER
Debug: privValue
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: privValue
Debug: 
Debug: 
Debug: Found symbol: privValue
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ecx + 4] [ecx + 4]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: v
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: v
Debug: 
Debug: 
Debug: Found symbol: v
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ebp + 8] [ebp + 8]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: jump_statement -> RETURN ;
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: 
Debug: fname: Demo.setPrivate_int
Debug: lastFnType in external: void
Debug: 
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: Demo
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: type_specifier -> INT
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: int
Debug: 
Debug: lastFnType in external: int
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: 1
Debug: Method 'getPrivate' with return type 'int' declared.
Debug: 2
Debug: 12qwr
Debug: 0
Debug: primary_expression -> IDENTIFIER
Debug: privValue
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: privValue
Debug: 
Debug: 
Debug: Found symbol: privValue
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ecx + 4] [ecx + 4]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: 3
Debug: getPrivate
Debug: Return type: int, Expected type: int
Debug: Method 'getPrivate' has return statement returning 'privValue'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: Demo
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: type_specifier -> VOID
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: void
Debug: type_specifier -> INT
Debug: pointer_opt -> <empty>
Debug: return_type -> type_specifier pointer_opt
Debug: parameter_declaration -> return_type IDENTIFIER
Debug: Parameter: v of type which is: int
Debug: parameter_list -> parameter_declaration
Debug: 
Debug: lastDeclType in external: void
Debug: 
Debug: external -> IDENTIFIER ( parameter_list )
Debug: Parameter: v of type int
Debug: Parameter declare: v of type int
Debug: int
Debug: q: int
Debug: stars: 
Debug: 12qwr
Debug: 0
Debug: primary_expression -> IDENTIFIER
Debug: protValue
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: protValue
Debug: 
Debug: 
Debug: Found symbol: protValue
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ecx + 8] [ecx + 8]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: v
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: v
Debug: 
Debug: 
Debug: Found symbol: v
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ebp + 8] [ebp + 8]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: jump_statement -> RETURN ;
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( parameter_list ) compound_statement
Debug: 
Debug: fname: Demo.setProtected_int
Debug: lastFnType in external: void
Debug: 
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: Demo
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: type_specifier -> INT
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: int
Debug: 
Debug: lastFnType in external: int
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: 1
Debug: Method 'getProtected' with return type 'int' declared.
Debug: 2
Debug: 12qwr
Debug: 0
Debug: primary_expression -> IDENTIFIER
Debug: protValue
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: protValue
Debug: 
Debug: 
Debug: Found symbol: protValue
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ecx + 8] [ecx + 8]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: 3
Debug: getProtected
Debug: Return type: int, Expected type: int
Debug: Method 'getProtected' has return statement returning 'protValue'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: Demo
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: type_specifier -> VOID
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: void
Debug: 
Debug: lastFnType in external: void
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: 1
Debug: Method 'showAll' with return type 'void' declared.
Debug: 2
Debug: 12qwr
Debug: 0
Debug: primary_expression -> IDENTIFIER
Debug: printf
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: printf
Debug: 
Debug: postfix_expression -> primary_expression
Debug: constant -> STRING_LITERAL
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is char*
Debug: 
Debug: primary_expression -> IDENTIFIER
Debug: pubValue
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: pubValue
Debug: 
Debug: 
Debug: Found symbol: pubValue
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ecx + 0] [ecx + 0]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> argument_expression_list , assignment_expression
Debug: argcount is 2, type is int
Debug: pubValue-[ecx + 0]
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: printf
Debug: 
Debug: argCount is:2
Debug: type is char*
Debug: type is int
Debug: name is: printf_charptr_int
Debug: New temp: [ebp - 4]
Debug: sym->name: [ebp - 4]
Debug: sym->printName: [ebp - 4]
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: primary_expression -> IDENTIFIER
Debug: printf
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: printf
Debug: 
Debug: postfix_expression -> primary_expression
Debug: constant -> STRING_LITERAL
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is char*
Debug: 
Debug: primary_expression -> IDENTIFIER
Debug: privValue
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: privValue
Debug: 
Debug: 
Debug: Found symbol: privValue
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ecx + 4] [ecx + 4]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> argument_expression_list , assignment_expression
Debug: argcount is 2, type is int
Debug: privValue-[ecx + 4]
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: printf
Debug: 
Debug: argCount is:2
Debug: type is char*
Debug: type is int
Debug: name is: printf_charptr_int
Debug: New temp: [ebp - 8]
Debug: sym->name: [ebp - 8]
Debug: sym->printName: [ebp - 8]
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: printf
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: printf
Debug: 
Debug: postfix_expression -> primary_expression
Debug: constant -> STRING_LITERAL
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is char*
Debug: 
Debug: primary_expression -> IDENTIFIER
Debug: protValue
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: protValue
Debug: 
Debug: 
Debug: Found symbol: protValue
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ecx + 8] [ecx + 8]
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> argument_expression_list , assignment_expression
Debug: argcount is 2, type is int
Debug: protValue-[ecx + 8]
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: printf
Debug: 
Debug: argCount is:2
Debug: type is char*
Debug: type is int
Debug: name is: printf_charptr_int
Debug: New temp: [ebp - 12]
Debug: sym->name: [ebp - 12]
Debug: sym->printName: [ebp - 12]
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: jump_statement -> RETURN ;
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: Demo
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: Demo
Debug: struct_or_class_specifier -> struct_or_class IDENTIFIER { struct_or_class_member_list }
Debug: external_declaration -> struct_or_class_specifier ;
Debug: translation_unit -> external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: 
Debug: lastFnType in external: int
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: Function 'main' with return type 'int' declared.
Debug: 12qwr
Debug: 0
Debug: primary_expression -> IDENTIFIER
Debug: printf
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: printf
Debug: 
Debug: postfix_expression -> primary_expression
Debug: constant -> STRING_LITERAL
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is char*
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: printf
Debug: 
Debug: argCount is:1
Debug: type is char*
Debug: name is: printf_charptr
Debug: New temp: [ebp - 4]
Debug: sym->name: [ebp - 4]
Debug: sym->printName: [ebp - 4]
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: type_specifier -> TYPE_NAME
Debug: User defined type found: Demo
Debug: declaration_specifiers -> type_specifier
Debug: Demo
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333d
Debug: utla
Debug: 
Debug: Declared variable is: d of type: Demo and kind: 
Debug: 
Debug: 
Debug: d.showAll
Debug: zz
Debug: d.showAll
Debug: Function 'd.showAll' with return type 'void' declared.
Debug: d.getProtected
Debug: zz
Debug: d.getProtected
Debug: Function 'd.getProtected' with return type 'int' declared.
Debug: d.setProtected
Debug: zz
Debug: d.setProtected_int
Debug: Function 'd.setProtected_int' with return type 'void' declared.
Debug: d.getPrivate
Debug: zz
Debug: d.getPrivate
Debug: Function 'd.getPrivate' with return type 'int' declared.
Debug: d.setPrivate
Debug: zz
Debug: d.setPrivate_int
Debug: Function 'd.setPrivate_int' with return type 'void' declared.
Debug: offset of d.protValue is 8
Debug: mmm
Debug: main.d.protValue
Debug: Variable 'd.protValue' with type 'int' declared.
Debug: offset of d.privValue is 4
Debug: mmm
Debug: main.d.privValue
Debug: Variable 'd.privValue' with type 'int' declared.
Debug: offset of d.pubValue is 0
Debug: mmm
Debug: main.d.pubValue
Debug: Variable 'd.pubValue' with type 'int' declared.
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: Demo
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: Demo
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: d
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: d
Debug: 
Debug: 
Debug: Found symbol: d
Debug: Type: Demo
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ebp - 16] [ebp - 16]
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentname is [ebp - 16]
Debug: currentType is Demo
Debug: 2ss12121
Debug: d.pubValue
Debug: 
Debug: 1
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 10
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: [ebp - 16]
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: d
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: d
Debug: 
Debug: 
Debug: Found symbol: d
Debug: Type: Demo
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ebp - 16] [ebp - 16]
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentname is [ebp - 16]
Debug: currentType is Demo
Debug: 2ss12121
Debug: d.setPrivate
Debug: 
Debug: function
Debug: 1
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 20
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: d.setPrivate
Debug: 
Debug: argCount is:1
Debug: type is int
Debug: name is: d.setPrivate_int
Debug: Demo.setPrivate_int
Debug: 4
Debug: pname is: d
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: d
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: d
Debug: 
Debug: 
Debug: Found symbol: d
Debug: Type: Demo
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ebp - 16] [ebp - 16]
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentname is [ebp - 16]
Debug: currentType is Demo
Debug: 2ss12121
Debug: d.setProtected
Debug: 
Debug: function
Debug: 1
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 30
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is int
Debug: 
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: d.setProtected
Debug: 
Debug: argCount is:1
Debug: type is int
Debug: name is: d.setProtected_int
Debug: Demo.setProtected_int
Debug: 4
Debug: pname is: d
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: printf
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: printf
Debug: 
Debug: postfix_expression -> primary_expression
Debug: constant -> STRING_LITERAL
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> assignment_expression
Debug: 
Debug: argcount is 1, type is char*
Debug: 
Debug: primary_expression -> IDENTIFIER
Debug: d
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: d
Debug: 
Debug: 
Debug: Found symbol: d
Debug: Type: Demo
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ebp - 16] [ebp - 16]
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentname is [ebp - 16]
Debug: currentType is Demo
Debug: 2ss12121
Debug: d.getPrivate
Debug: 
Debug: function
Debug: 1
Debug: postfix_expression -> postfix_expression ( )
Debug: 2123
Debug: d.getPrivate
Debug: 4
Debug: pname is: d
Debug: New temp: [ebp - 20]
Debug: sym->name: [ebp - 20]
Debug: sym->printName: [ebp - 20]
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: argument_expression_list -> argument_expression_list , assignment_expression
Debug: argcount is 2, type is int
Debug: [ebp - 20]-
Debug: postfix_expression -> postfix_expression ( argument_expression_list )
Debug: 133
Debug: printf
Debug: 
Debug: argCount is:2
Debug: type is char*
Debug: type is int
Debug: name is: printf_charptr_int
Debug: New temp: [ebp - 24]
Debug: sym->name: [ebp - 24]
Debug: sym->printName: [ebp - 24]
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: d
Debug: lksajdlajdkadn
Debug: 
Debug: Looking up symbol: d
Debug: 
Debug: 
Debug: Found symbol: d
Debug: Type: Demo
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: [ebp - 16] [ebp - 16]
Debug: postfix_expression -> primary_expression
Debug: postfix_expression -> postfix_expression . IDENTIFIER
Debug: currentname is [ebp - 16]
Debug: currentType is Demo
Debug: 2ss12121
Debug: d.getProtected
Debug: 
Debug: function
Debug: 1
Debug: postfix_expression -> postfix_expression ( )
Debug: 2123
Debug: d.getProtected
Debug: 4
Debug: pname is: d
Debug: New temp: [ebp - 28]
Debug: sym->name: [ebp - 28]
Debug: sym->printName: [ebp - 28]
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: Demo
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: int, Expected type: int
Debug: 
Debug: lastDeclType: Demo
Debug: currentFunction: main
Debug: 
Debug: Function 'main' has return statement returning '0'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
