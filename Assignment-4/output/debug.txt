Debug: struct_or_class -> CLASS
Debug: named struct/class: A
Debug: struct_or_class_member_list -> <empty>
Debug: lastClassType: A
Debug: access_specifier_label -> PUBLIC :
Debug: lastClassType: A
Debug: struct_or_class_member -> access_specifier_label
Debug: lastClassType: A
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> INT
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333a
Debug: 12a
Debug: 
Debug: 13
Debug: 
Debug: Declared variable is: a of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: external -> init_declarator_list ;
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: type_specifier -> VOID
Debug: external_declare -> type_specifier
Debug: lastDeclType in external_declare: void
Debug: 
Debug: lastFnType in external: void
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: 1
Debug: Method 'fn' with return type 'void' declared.
Debug: 2
Debug: 12qwr
Debug: 0
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: this + 0 this + 0
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 10
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: void
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: this + 0
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333c
Debug: 
Debug: Declared variable is: c of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: c
Debug: 
Debug: Looking up symbol: c
Debug: 
Debug: 
Debug: Found symbol: c
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 0 spr - 0
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: this + 0 this + 0
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: jump_statement -> RETURN ;
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declare -> type_specifier external
Debug: struct_or_class_member -> external_declare
Debug: lastClassType: A
Debug: 
Debug: struct_or_class_member_list -> struct_or_class_member_list struct_or_class_member
Debug: lastClassType: A
Debug: struct_or_class_specifier -> struct_or_class IDENTIFIER { struct_or_class_member_list }
Debug: external_declaration -> struct_or_class_specifier ;
Debug: translation_unit -> external_declaration
Debug: type_specifier -> INT
Debug: external_declaration -> type_specifier
Debug: lastDeclType in external_declaration: int
Debug: 
Debug: lastFnType in external: int
Debug: 
Debug: external -> IDENTIFIER ( )
Debug: Function 'main' with return type 'int' declared.
Debug: 12qwr
Debug: 0
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333a
Debug: 
Debug: Declared variable is: a of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333c
Debug: 
Debug: Declared variable is: c of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator_list , init_declarator
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 0 spr - 0
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 5
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: spr - 0
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> CHAR
Debug: declaration_specifiers -> type_specifier
Debug: char
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333b
Debug: 
Debug: Declared variable is: b of type: char and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: char
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: char
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: b
Debug: 
Debug: Looking up symbol: b
Debug: 
Debug: 
Debug: Found symbol: b
Debug: Type: char
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 8 spr - 8
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: constant -> CHARACTER_LITERAL
Debug: 
Debug: Character constant value: a
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: char
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: spr - 8
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: 12qwr
Debug: 9
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333e
Debug: 
Debug: Declared variable is: e of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> block_item
Debug: primary_expression -> IDENTIFIER
Debug: e
Debug: 
Debug: Looking up symbol: e
Debug: 
Debug: 
Debug: Found symbol: e
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 9 spr - 9
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 0 spr - 0
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: statement -> compound_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333f
Debug: 
Debug: Declared variable is: f of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: f
Debug: 
Debug: Looking up symbol: f
Debug: 
Debug: 
Debug: Found symbol: f
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 9 spr - 9
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 0 spr - 0
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: type_specifier -> INT
Debug: declaration_specifiers -> type_specifier
Debug: int
Debug: init_declarator -> IDENTIFIER 
Debug: flf
Debug: 333g
Debug: 
Debug: Declared variable is: g of type: int and kind: 
Debug: 
Debug: 
Debug: 
Debug: init_declarator_list -> init_declarator
Debug: int
Debug: declaration -> declaration_specifiers init_declarator_list ;
Debug: int
Debug: block_item -> declaration
Debug: statement_list -> statement_list block_item
Debug: primary_expression -> IDENTIFIER
Debug: g
Debug: 
Debug: Looking up symbol: g
Debug: 
Debug: 
Debug: Found symbol: g
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 13 spr - 13
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: assignment_operator -> =
Debug: primary_expression -> IDENTIFIER
Debug: a
Debug: 
Debug: Looking up symbol: a
Debug: 
Debug: 
Debug: Found symbol: a
Debug: Type: int
Debug: Kind: 
Debug: Dimensions: 0
Debug: 
Debug: spr - 0 spr - 0
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: assignment_expression -> unary_expression assignment_operator assignment_expression
Debug: 11:
Debug: abcdefgh
Debug: expression -> assignment_expression
Debug: expression_statement -> expression ;
Debug: statement -> expression_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: constant -> DECIMAL_LITERAL
Debug: 
Debug: Integer constant value: 0
Debug: 
Debug: primary_expression -> constant
Debug: postfix_expression -> primary_expression
Debug: unary_expression -> postfix_expression
Debug: cast_expression -> unary_expression
Debug: int
Debug: multiplicative_expression -> cast_expression
Debug: additive_expression -> multiplicative_expression
Debug: shift_expression -> additive_expression
Debug: relational_expression -> shift_expression
Debug: equality_expression -> relational_expression
Debug: and_expression -> equality_expression
Debug: exclusive_or_expression -> and_expression
Debug: inclusive_or_expression -> exclusive_or_expression
Debug: logical_and_expression -> inclusive_or_expression
Debug: logical_or_expression -> logical_and_expression
Debug: conditional_expression -> logical_or_expression
Debug: assignment_expression -> conditional_expression
Debug: expression -> assignment_expression
Debug: jump_statement -> RETURN expression ;
Debug: Return type: int, Expected type: int
Debug: 
Debug: lastDeclType: int
Debug: currentFunction: main
Debug: 
Debug: Function 'main' has return statement returning '0'.
Debug: statement -> jump_statement
Debug: block_item -> statement
Debug: statement_list -> statement_list block_item
Debug: compound_statement -> { statement_list }
Debug: external -> IDENTIFIER ( ) compound_statement
Debug: external_declaration -> type_specifier external
Debug: translation_unit -> translation_unit external_declaration
